"""Modified version of phonolammps for my personal use in nanowire simulations"""
import os
from math import sqrt

import numpy as np
from phonopy.structure.atoms import PhonopyAtoms

from my_phonolammps._phonolammps import (MyPhonoBase,
                                         unit_factors,
                                         mass_to_symbol,
                                         get_phonon,
                                         obtain_phonon_dispersion_bands,
                                         generate_VASP_structure)

__version__ = "2021.2"


def read_structure_params_from_dump(dump_file: str, na: int):
    ids, masses, symbols = [], [], []
    positions = np.zeros((na, 3), dtype='double')
    with open(dump_file) as f:
        line = f.readline()
        while line and not line.startswith("ITEM: ATOMS"):
            line = f.readline()
        if not line:
            raise ValueError("could not find 'ITEM: ATOMS' section in ", dump_file)

        line = f.readline()
        i = 0
        while i < na:
            line = line.strip()
            nums = line.split()
            atom_id = int(nums[0])
            mass = float(nums[1])
            symbol = mass_to_symbol(mass)
            position = [float(s) for s in nums[2:5]]

            ids.append(atom_id)
            masses.append(mass)
            symbols.append(symbol)
            positions[i] = position
            line = f.readline()
            i += 1

    os.remove(dump_file)
    return ids, masses, symbols, positions


def read_forces_from_dump(dump_file: str):
    with open(dump_file) as f:
        line = f.readline()
        while line and not line.startswith("ITEM: NUMBER OF ATOMS"):
            line = f.readline()
        if not line:
            raise ValueError("could not find 'ITEM: NUMBER OF ATOMS' section in ", dump_file)

        n_atoms = int(f.readline().strip())
        forces = np.zeros((n_atoms, 3), dtype='double')

        line = f.readline()
        while line and not line.startswith("ITEM: ATOMS"):
            line = f.readline()
        if not line:
            raise ValueError("could not find 'ITEM: ATOMS' section in ", dump_file)

        line = f.readline()
        i = 0
        while i < n_atoms:
            forces[i] = [float(s) for s in line.strip().split()]
            line = f.readline()
            i += 1

    return forces


class MyPhonopyAtoms(PhonopyAtoms):
    def __init__(self, original_positions, masses, symbols, cell, ids):
        super().__init__(positions=original_positions,
                         masses=masses,
                         symbols=symbols,
                         cell=cell)

        self._ids = np.asarray(ids)

    @property
    def ids(self):
        return self._ids

    def write_as_lammps_data(self, file_name):
        """for debugging: writes current positions with original atom ID order"""
        positions = self.positions
        numbers = self.numbers
        cell = self.cell

        xlo = ylo = zlo = 0.0
        xhi = cell[0][0]
        yhi = cell[1][1]
        zhi = cell[2][2]
        xy = cell[1][0]
        xz = cell[2][0]
        yz = cell[2][1]

        typ_dict = {num: i + 1 for i, num in enumerate(np.unique(self.numbers))}
        n_atom_types = len(typ_dict)

        with open(file_name, 'w') as f:
            f.write("structure data file generated by MyPhonolammps\n")
            f.write("\n")
            f.write("{:d} atoms\n".format(len(numbers)))
            f.write("{:d} atom types\n".format(n_atom_types))
            f.write("\n")
            f.write("{:f} {:f} xlo xhi\n".format(xlo, xhi))
            f.write("{:f} {:f} ylo yhi\n".format(ylo, yhi))
            f.write("{:f} {:f} zlo zhi\n".format(zlo, zhi))
            f.write("{:f} {:f} {:f} xy xz yz\n".format(xy, xz, yz))
            f.write("\nAtoms # atomic\n")
            f.write("\n")

            i_atom = 0
            for pos, num in zip(positions, numbers):
                f.write("{:d} {:d} {:f} {:f} {:f}\n"
                        .format(self.ids[i_atom], typ_dict[num], *pos))
                i_atom += 1
            f.write("\n")


class MyPhonolammps(MyPhonoBase):
    """
    A rewrite of the original, because it seems to shuffle the atom order
    in my structure when extracting properties from LAMMPS.

    I will avoid extracting atom properties, instead (stupidly) writing
    a SORTED dump file and reading it every time.
    """

    def get_forces(self, cell_with_disp):
        """
        I have rewritten this to use dump files and MyPhonopyAtoms.
        The point is to avoid shuffling atoms in the structure.

        ORIGINAL DOCSTRING:

        Calculate the forces of a supercell using lammps

        :param cell_with_disp: supercell from which determine the forces
        :return: numpy array matrix with forces of atoms [N_atoms x 3]
        """
        import lammps

        cmd_list = ['-log', 'none']
        if not self._show_log:
            cmd_list += ['-echo', 'none', '-screen', 'none']

        lmp = lammps.lammps(cmdargs=cmd_list)
        lmp.commands_list(self._lammps_commands_list)
        lmp.command('replicate {} {} {}'
                    .format(*np.diag(self._supercell_matrix).astype(int)))
        lmp.command('run 0')

        coordinates = cell_with_disp.get_positions()
        for i, atom_id in enumerate(self._structure.ids):
            lmp.command("set atom {:d} x {:f} y {:f} z {:f}"
                        .format(atom_id, *coordinates[i]))
        lmp.command("run 0")

        # tell LAMMPS to dump the relevant info
        _temp_file_ = self._next_temp_file_name("_FORCES_DUMP_")
        lmp.commands_list([
            "dump _GetForcesDump_ all custom 1 {} fx fy fz".format(_temp_file_),
            "dump_modify _GetForcesDump_ sort id"
            " format 1 %20.15g format 2 %20.15g format 3 %20.15g",
            "run 0",
            "undump _GetForcesDump_"
        ])
        lmp.close()

        forces = read_forces_from_dump(_temp_file_) * unit_factors[self.units]

        return forces

    def write_force_constants(self,
                              filename: str = 'FORCE_CONSTANTS',
                              hdf5: bool = False,
                              omit_zeros: bool = True,
                              omit_zeros_thresh: float = 1e-6) -> None:
        """
        Write the force constants in a file in phonopy plain text format

        :param filename: force constants filename
        :param hdf5: write to HDF5 file
        :param omit_zeros: omit writing all-zero entries in the output file
        :param omit_zeros_thresh: omit force constant matrices with norm below this value
        """
        if hdf5:
            # deferring HDF5 writing to super class for now
            super().write_force_constants(filename, hdf5)
            return

        force_constants = self.get_force_constants()
        fc_shape = force_constants.shape
        dim = fc_shape[-1]
        indices = np.arange(fc_shape[0], dtype='intc')

        with open(filename, 'w') as fc_file:

            # write total number of interactions (including 0-matrices)
            fc_file.write("%4d %4d\n" % fc_shape[:2])

            if omit_zeros:
                # only write when interaction matrix norm isn't too small
                for i, s_i in enumerate(indices):
                    for j in range(fc_shape[1]):
                        norm = 0.0
                        for vec in force_constants[i][j]:
                            norm += np.linalg.norm(vec)
                        if norm > omit_zeros_thresh:
                            fc_file.write("%d %d\n" % (s_i + 1, j + 1))
                            for vec in force_constants[i][j]:
                                fc_file.write(("%22.15f" * dim + "\n") % tuple(vec))
            else:
                # write every line
                for i, s_i in enumerate(indices):
                    for j in range(fc_shape[1]):
                        fc_file.write("%d %d\n" % (s_i + 1, j + 1))
                        for vec in force_constants[i][j]:
                            fc_file.write(("%22.15f" * dim + "\n") % tuple(vec))

    def write_harmonic_constants(self,
                                 filename: str = "HARMONIC_CONSTANTS",
                                 omit_zeros: bool = True,
                                 omit_zeros_thresh: float = 1e-6) -> None:
        """
        Write the harmonic constants (force_constants[i][j] / sqrt(mass[i] * mass[j]))
        in the same format as force constants.

        :param filename: force constants filename
        :param omit_zeros: omit writing all-zero entries in the output file
        :param omit_zeros_thresh: omit harmonic constant matrices with norm below this value
        """

        force_constants = self.get_force_constants()
        masses = self._structure.masses
        fc_shape = force_constants.shape
        dim = fc_shape[-1]
        indices = np.arange(fc_shape[0], dtype='intc')

        with open(filename, 'w') as hc_file:

            # write total number of interactions (including 0-matrices)
            hc_file.write("%4d %4d\n" % fc_shape[:2])

            if omit_zeros:
                # only write when interaction matrix norm isn't too small
                for i, s_i in enumerate(indices):
                    for j in range(fc_shape[1]):
                        m_i = masses[i]
                        m_j = masses[j]

                        norm = 0.0
                        for vec in force_constants[i][j]:
                            norm += np.linalg.norm(vec)
                        if norm > omit_zeros_thresh:
                            hc_file.write("%d %d\n" % (s_i + 1, j + 1))
                            for vec in force_constants[i][j]:
                                hc_file.write(("%22.15f" * dim + "\n")
                                              % tuple(vec / sqrt(m_i * m_j)))
            else:
                # write every line
                for i, s_i in enumerate(indices):
                    for j in range(fc_shape[1]):
                        m_i = masses[i]
                        m_j = masses[j]

                        # write interaction sub-matrix [i][j]
                        hc_file.write("%d %d\n" % (s_i + 1, j + 1))
                        for vec in force_constants[i][j]:
                            hc_file.write(("%22.15f" * dim + "\n")
                                          % tuple(vec / sqrt(m_i * m_j)))

    def __init__(self,
                 lammps_input,
                 supercell_matrix=np.identity(3),
                 primitive_matrix=np.identity(3),
                 displacement_distance=0.01,
                 trash_counter_max=50,
                 show_log=False,
                 show_progress=False,
                 use_NAC=False,
                 symmetrize=True,
                 recenter_atoms=True):
        """
        [a modified version of the] Main PhonoLAMMPS class

        :param lammps_input: LAMMPS input file name or list of commands
        :param supercell_matrix:  3x3 matrix supercell
        :param primitive_matrix:  3x3 matrix primitive cell
        :param displacement_distance: displacement distance in Angstroms
        :param trash_counter_max: maximum number of temp files written before overwriting
        :param show_log: Set true to display lammps log info
        :param show_progress: Set true to display progress of calculation
        """
        super().__init__()

        # Check if input is file or list of commands
        if type(lammps_input) is str:
            # read from file name
            self._lammps_input_file = lammps_input
            self._lammps_commands_list = open(lammps_input).read().split('\n')
        else:
            # read from commands
            self._lammps_commands_list = lammps_input

        self._supercell_matrix = supercell_matrix
        self._primitive_matrix = primitive_matrix
        self._displacement_distance = displacement_distance
        self._trash_counter_max = trash_counter_max
        self._show_log = show_log
        self._show_progress = show_progress
        self._symmetrize = symmetrize
        self._NAC = use_NAC

        # replaced this with my own method
        self._structure = self._get_structure_from_lammps(recenter_atoms)

        self._force_constants = None
        self._data_set = None

        # to avoid permission errors when deleting large files after reading
        self._trash_dir = "./__phl_trash__"
        if not os.path.isdir(self._trash_dir):
            os.mkdir(self._trash_dir)
        self._temp_name_counter = 1

        self.units = self.get_units(self._lammps_commands_list)

        if self.units not in unit_factors.keys():
            print('Units style not supported, use: {}'.format(unit_factors.keys()))
            exit()

    def __del__(self):
        """clean up temporary files"""
        os.system("rm -rf %s" % self._trash_dir)

    def _next_temp_file_name(self, basename):
        """assign name for temporary kinds with same basename"""
        if self._temp_name_counter > self._trash_counter_max:
            # overwrite oldest files
            self._temp_name_counter = 1
        else:
            self._temp_name_counter += 1
        _file_name = "/".join([self._trash_dir, basename + str(self._temp_name_counter)])
        return _file_name

    def _get_structure_from_lammps(self, recenter_atoms=True):
        """my version that (hopefully) won't shuffle atoms"""
        from lammps import lammps

        cmd_list = ['-log', 'none']
        if not self._show_log:
            cmd_list += ['-echo', 'none', '-screen', 'none']

        lmp = lammps(cmdargs=cmd_list)
        lmp.commands_list(self._lammps_commands_list)

        # extract box as before
        try:
            xlo = lmp.extract_global("boxxlo", 1)
            xhi = lmp.extract_global("boxxhi", 1)
            ylo = lmp.extract_global("boxylo", 1)
            yhi = lmp.extract_global("boxyhi", 1)
            zlo = lmp.extract_global("boxzlo", 1)
            zhi = lmp.extract_global("boxzhi", 1)
            xy = lmp.extract_global("xy", 1)
            yz = lmp.extract_global("yz", 1)
            xz = lmp.extract_global("xz", 1)
        except UnboundLocalError:
            boxlo, boxhi, xy, yz, xz, periodicity, box_change = lmp.extract_box()
            xlo, ylo, zlo = boxlo
            xhi, yhi, zhi = boxhi

        # note: box is mapped to the first quadrant here
        unitcell = np.array([[xhi - xlo, xy, xz],
                             [0, yhi - ylo, yz],
                             [0, 0, zhi - zlo]]).T

        # tell LAMMPS to dump the relevant info
        _temp_file_ = "_STRUCTURE_DUMP_"
        lmp.commands_list([
            "dump _GetStructureDump_ all custom 1 {} id mass x y z".format(_temp_file_),
            "dump_modify _GetStructureDump_ sort id"
            " format 3 %20.15g format 4 %20.15g format 5 %20.15g",  # IMPORTANT
            "run 0",
            "undump _GetStructureDump_"
        ])
        na = lmp.get_natoms()
        lmp.close()

        ids, masses, symbols, positions = read_structure_params_from_dump(_temp_file_, na)

        if recenter_atoms:
            # keep atoms positions same relative to the box
            positions = np.asarray(positions) - np.array([xlo, ylo, zlo])

        return MyPhonopyAtoms(original_positions=positions,
                              masses=masses,
                              symbols=symbols,
                              cell=unitcell,
                              ids=ids)

    def write_structure(self, file_name):
        self._structure.write_as_lammps_data(file_name)

    @staticmethod
    def get_units(commands_list):
        """
        Get the units label for LAMMPS "units" command from a list of LAMMPS input commands

        :param commands_list: list of LAMMPS input commands (strings)
        :return units: string containing the units
        """
        for line in commands_list:
            if line.startswith('units'):
                return line.split()[1]
        return 'lj'

    @staticmethod
    def get_force_constants_lines(matrix: np.ndarray,
                                  omit_zeros: bool,
                                  omit_zeros_thresh: float):
        indices = np.arange(matrix.shape[0], dtype='intc')
        lines = []
        _shape = matrix.shape
        lines.append("%4d %4d" % _shape[:2])
        dim = _shape[3]

        if omit_zeros:
            # check interaction matrix norm isn't too small
            for i, s_i in enumerate(indices):
                for j in range(_shape[1]):
                    norm = 0.0
                    for vec in matrix[i][j]:
                        norm += np.linalg.norm(vec)
                    if norm > omit_zeros_thresh:
                        lines.append("%d %d" % (s_i + 1, j + 1))
                        for vec in matrix[i][j]:
                            lines.append(("%22.15f" * dim) % tuple(vec))
        else:
            # write every line
            for i, s_i in enumerate(indices):
                for j in range(_shape[1]):
                    lines.append("%d %d" % (s_i + 1, j + 1))
                    for vec in matrix[i][j]:
                        lines.append(("%22.15f" * dim) % tuple(vec))

        return lines
